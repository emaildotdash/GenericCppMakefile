##
## Generic Makefile for mid-sized cross-platform C++ projects
## Author: Ádám "emaildotdash" Gutási
## License: MIT
## Commands: <default>/all, exec, dynamic, static, run, clean/clear, cleanall/clearall, info, package, fetch, snip
## Github: https://github.com/emaildotdash/GenericCppMakefile
##
##############################################################


### project specific

## project name (optional)
PROJNAME :=

## directory tree settings
# filename of the output file (without extension)
MAIN := main
# source file directories (preferrably in a subdirectory; any number of them; entries should not overlap)
SRC := src
# execution path (where the program should be run from; exactly one)
EXECPATH := .
# describe how the executable is run by 'make run'; <command> gets substituted for the execution command
EXECARGS := <command>

## build target
# executable / dynamiclib / staticlib
TARGETTYPE := executable
# release / debug
TARGETOPTIM := debug

## external libraries
# extra include paths (dirs with header files)
INCLUDEDIRS := include
# extra library paths (dirs with library files; first entry should be local if this is part of a superproject)
LIBRARYDIRS := lib
# name of library to be used (write ONLY the name of the lib and NOT the full filename, meaning:
# if the lib-file looks like 'lib[name].so' or 'lib[name].a' -> you write [name]
# or on windows: '[name].dll' or '[name].lib' -> you write [name])
LIBRARIES :=

## compiler and flags (see gcc manual; DEBUG- and RELEASEFLAGS are used only with the respective build target; -MMD flag is automatically added)
CXX := g++
FLAGS := -std=c++20 -Wall -Wl,-R./lib
DEBUGFLAGS := -Wextra -g
RELEASEFLAGS := -O3 -DNDBUG

# WARNING: make sure you put no extra files in any output-directory,
# entry names with whitespaces must be written in "quotes"
# and make sure there's no extra whitespace following the entries
# e.g.: "... := entry  " is bad
#       "... := entry"   is good

# NOTE: directory paths in any above entry may be either relative or absolute unless specified otherwise

# NOTE: passing release or debug after a build call as SPECIFICALLY the second target will build the project with that in mind
# e.g.: make all release, make static debug


# you can make a "snippet" file that contains project independent code you may want to test
# compile and run via "make snip"; output gets cleaned up by cleanall
SNIPPETFILE := ./snip.cpp
# filepaths to shell scripts that are run automatically upon compilation after any change
TESTSCRIPTS :=


##############################################################
###################### DO NOT CHANGE #########################

# general info
OS := $(shell uname -o)# operating system
PROJDIR := $(shell pwd)# absolute directory of this project
SRCDIRS := $(shell find $(SRC) -type d)# all source directories
OUTPUT_BASE := output# directory that compiled files go to
PACKAGEDIR := $(if $(PROJNAME),"$(PROJNAME)","packaged_ver")# directory for a potential packaged version

# set target optimization depending on 2nd target (only here for compatibility with superprojects; don't use this functionality)
ifeq ($(word 2,$(MAKECMDGOALS)),release)
TARGETOPTIM = release
else ifeq ($(word 2,$(MAKECMDGOALS)),debug)
TARGETOPTIM = debug
endif

# compiler flags and output path according to build target
CXXFLAGS := $(FLAGS)
ifeq ($(TARGETOPTIM),release)
CXXFLAGS += $(RELEASEFLAGS)
OUTPUT = $(OUTPUT_BASE)/release
else ifeq ($(TARGETOPTIM),debug)
CXXFLAGS += $(DEBUGFLAGS)
OUTPUT = $(OUTPUT_BASE)/debug
endif
CXXFLAGS += -MMD

# cross platform stuff
ifeq ($(OS),Windows)
MAINOUT_DYNAMIC := $(OUTPUT)/$(MAIN).dll
MAINOUT_STATIC := $(OUTPUT)/$(MAIN).lib
MAINOUT := $(OUTPUT)/$(MAIN).exe
else
MAINOUT_DYNAMIC := $(OUTPUT)/lib$(MAIN).so
MAINOUT_STATIC := $(OUTPUT)/lib$(MAIN).a
MAINOUT := $(OUTPUT)/$(MAIN)
endif

# set flag to prevent the printing of directories
ifndef VERBOSE
MAKEFLAGS += --no-print-directory
endif

# headers and libraries
INCDIRS := -I/usr/include $(INCLUDEDIRS:%=-I%)
LIBDIRS := -L/usr/lib $(LIBRARYDIRS:%=-L%)
LIBS := $(LIBRARIES:%=-l%)

# file extensions
SOURCE_TYPES := .c .C .cc .cpp .CPP .c++ .cp .cxx
HEADER_TYPES := .h .hh .H .hp .hxx .hpp .HPP .h++ .tcc

# source files
SOURCES_SRC := $(foreach WRD,$(SOURCE_TYPES),$(wildcard $(SRCDIRS:%=%/*$(WRD))))# finds all source files

OUTPUT_SRCDIRS := $(SRCDIRS:%=$(OUTPUT)/%)# source directories to be copied to ./output to make the file structure nice

# object files
OBJECTS := $(SOURCES_SRC:%=$(OUTPUT)/%.o)

# dependency files
DEPS := $(OBJECTS:.o=.d)# all .d files generated by gcc for proper dependency checks

#################################
# all target <default>

all: OPTIM = $(if $(word 2,$(MAKECMDGOALS)),$(word 2,$(MAKECMDGOALS)),)# this is here to get rid of an error message

.PHONY: all
all: error
ifeq ($(TARGETTYPE),dynamiclib)
	make dynamic $(OPTIM)
else ifeq ($(TARGETTYPE),staticlib)
	make static $(OPTIM)
else ifeq ($(TARGETTYPE),executable)
	make exec $(OPTIM)
else
	@echo "MAKEFILE ERROR: Invalid target! Please set a proper target! (exec/dynamic/static)"
	@exit 001
endif
	@echo Project \'$(if $(PROJNAME),$(PROJNAME),"Unnamed Project")\' Built!

#################################
# executable binary target

.PHONY: exec
exec: error $(OUTPUT_SRCDIRS) $(MAINOUT)
	@echo "Binary executable built!"

$(MAINOUT): $(OBJECTS)
	$(CXX) $(CXXFLAGS) $(INCDIRS) $(LIBDIRS) $(LIBS) $^ -o $@
	$(foreach SCRIPT,$(TESTSCRIPTS),sh $(SCRIPT))

$(OBJECTS): $(OUTPUT)/%.o : %
	$(CXX) -c $(CXXFLAGS) -MF $(@:.o=.d) $(INCDIRS) $< -o $@

#################################
# dynamic lib (.so) target

# object file names appended with DYNAMIC to tell them apart from non-dynamiclib object files
# this isn't necessarely needed, but it makes it easier to tell what the project actally compiles to, considering there may be differences in compiler flags
DYNAMIC_OBJECTS := $(OBJECTS:.o=DYNAMIC.o)

.PHONY: dynamic
dynamic: error $(OUTPUT_SRCDIRS) $(MAINOUT_DYNAMIC)
	@echo "Dynamic library (.so) built!"

$(MAINOUT_DYNAMIC): $(DYNAMIC_OBJECTS)
	$(CXX) -shared $(CXXFLAGS) $(INCDIRS) $(LIBDIRS) $(LIBS) $^ -o $@
	$(foreach SCRIPT,$(TESTSCRIPTS),sh $(SCRIPT))

$(DYNAMIC_OBJECTS): $(OUTPUT)/%DYNAMIC.o : %
	$(CXX) -c -fPIC $(CXXFLAGS) -MF $(@:.o=.d) $(INCDIRS) $< -o $@

#################################
# static lib (.a) target

# object file names appended with STATIC to tell them apart from non-staticlib object files
# this isn't necessarely needed, but it makes it easier to tell what the project actally compiles to, considering there may be differences in compiler flags
STATIC_OBJECTS := $(OBJECTS:.o=STATIC.o)

.PHONY: static
static: error $(OUTPUT_SRCDIRS) $(MAINOUT_STATIC)
	@echo "Static library (.a) built!"

$(MAINOUT_STATIC): $(STATIC_OBJECTS)
	ar rcs $@ $^
	$(foreach SCRIPT,$(TESTSCRIPTS),sh $(SCRIPT))

$(STATIC_OBJECTS): $(OUTPUT)/%STATIC.o : %
	$(CXX) -c $(CXXFLAGS) -MF $(@:.o=.d) $(INCDIRS) $< -o $@

#################################
# miscellanious

# includes .d makefiles
-include $(DEPS)

# creates directory tree
$(OUTPUT):
	@mkdir -p $@
$(OUTPUT_SRCDIRS): $(OUTPUT)
	@mkdir -p $@

#################################
# more targets

.PHONY: run
run: all # compiles and runs the application
ifeq ($(TARGETTYPE),executable)
	@echo "\n============------------ EXECUTION OF: $(if $(PROJNAME),$(PROJNAME),"Unnamed Project") ------------============"
	cd $(EXECPATH) && $(subst <command>,$(PROJDIR)/$(MAINOUT),$(EXECARGS))
	@echo "\n============------------ EXECUTION FINISHED! ------------============"
else
	@echo Result compiled, but not run, as it is not an executable!
endif

.PHONY: clean clear
clean: # cleans up any files in the directory of the current build target
	rm -rf $(OUTPUT)/*
	@echo Cleanup complete!
clear: clean # alternate naming for clean operation

.PHONY: cleanall clearall
cleanall: # cleans up any files in the output directory
	rm -rf $(OUTPUT_BASE)/*
	rm -rf $(PACKAGEDIR)
	rm $(PROJDIR)/snip
	@echo Cleanup complete!
clearall: cleanall # alternate naming for cleanall operation

.PHONY: info
info: SOURCES_HEADERS := $(foreach WRD,$(HEADER_TYPES),$(wildcard $(SRCDIRS:%=%/*$(WRD))))# finds all header files
info: # prints a neat summary of project details
	@echo "|------------------------------------------ -- -  -"
	@echo "| Information about project: "$(if $(PROJNAME),$(PROJNAME),"Unnamed Project")
	@echo "|             os: "$(OS)
	@echo "|    project dir: "$(PROJDIR)
	@echo "|         target: "$(TARGETTYPE) $(TARGETOPTIM)
	@echo "|  external libs: "$(patsubst -l%,%,$(LIBS))
	@echo "|       compiler: "$(CXX)
	@echo "| src file count: "$(words $(SOURCES_SRC) $(SOURCES_HEADERS))
	@echo "|    source dirs: "$(SRC)
	@echo "|------------------------------- -- -  -"

.PHONY: fetch
fetch: ~/Templates/MakefileGenericCpp # fetches the most recent version of this Makefile from ~/Templates (creates it if it doesn't exist)
	@mv ./Makefile ./Makefile_old
	@cp ~/Templates/MakefileGenericCpp ./Makefile
	@echo Up-to-date Makefile template fetched!
~/Templates/MakefileGenericCpp:
	@cp ./Makefile ~/Templates/MakefileGenericCpp
	@echo Makefile template did not exist, so it has been created!

.PHONY: package
package: PKG_CONTENT := $(filter-out $(OUTPUT_BASE) $(SRC) Makefile,$(wildcard *))
package: # neatly packages the built binary alongside its assets (any files in its execution path excluding source dirs, output dir and the Makefile)
	mkdir -p $(PACKAGEDIR)
ifeq ($(TARGETTYPE),dynamiclib)
	cp $(MAINOUT_DYNAMIC) $(PACKAGEDIR)
else ifeq ($(TARGETTYPE),staticlib)
	cp $(MAINOUT_STATIC) $(PACKAGEDIR)
else
	cp $(MAINOUT) $(PACKAGEDIR)
endif
	cp -ar $(PKG_CONTENT) $(PACKAGEDIR)

.PHONY: snip
snip: $(SNIPPETFILE)
	$(CXX) -std=c++20 -Wall -Wl,-R./lib $(INCDIRS) $(LIBDIRS) $(LIBS) $^ -o snip
	cd $(EXECPATH) && $(PROJDIR)/snip


#################################
# compatibility targets (you shouldn't necessarely use these, but I mean, you certainly can)

.PHONY: debug release fetchall outdir libdir error
release: # gets rid of an unwanted error message
debug: # same as release
fetchall: fetch # redirects to fetch, in order to make fetchall work
outdir: # echoes the output directory
ifeq ($(TARGETTYPE),)
	@echo "MAKEFILE ERROR: The subproject called $(PROJNAME) does not have a proper target type."
	@exit 101
else
	@echo $(PROJDIR)/$(OUTPUT)
endif
libdir: # echoes library directories
ifeq ($(LIBRARYDIRS),)
	@echo "MAKEFILE ERROR: The subproject called $(PROJNAME) does not have a specified local library directory."
	@exit 201
else
	@echo $(PROJDIR)/$(firstword $(filter-out ~/% /%,$(LIBRARYDIRS)))
endif
error: # does some error checking in the main targets
ifneq ($(TARGETOPTIM),release) 
ifneq ($(TARGETOPTIM),debug)
	@echo "MAKEFILE ERROR: Invalid target! Please set a proper target! (release/debug)"
	@exit 002
endif
endif
